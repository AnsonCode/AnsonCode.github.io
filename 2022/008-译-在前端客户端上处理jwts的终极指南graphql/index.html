<!DOCTYPE html>
<html lang="zh-cn">
    <head>
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="robots" content="noodp"/>
    <meta name="author" content="Anson">
    <meta name="description" content="anson会写代码的产品经理，这是我的技术博客，专注产品设计及软件开发。">
    <meta name="keywords" content="golang;PMP">
    
    <link rel="prev" href="http://ansoncode.bazhentu.net/2022/006-%E8%AF%91-serverless%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6openfaasknative%E7%AD%89/" />
    <link rel="next" href="http://ansoncode.bazhentu.net/2022/009-%E8%AF%91-%E4%B9%90%E8%A7%82ui%E5%92%8C%E6%A1%A3%E6%A1%88%E9%94%80%E6%AF%81/" />
    <link rel="canonical" href="http://ansoncode.bazhentu.net/2022/008-%E8%AF%91-%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%A4%84%E7%90%86jwts%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97graphql/" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
    <title>
        
        
            008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL） | Anson`s Blog
        
    </title>
    <meta name="title" content="008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL） | Anson`s Blog">
    
<link rel="stylesheet" href="/css/main.min.css">


    
    
 

<script type="application/ld+json">
{
    "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/ansoncode.bazhentu.net\/"
    },
    "articleSection" : "posts",
    "name" : "008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL）",
    "headline" : "008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL）",
    "description" : "翻译自：The Ultimate Guide to handling JWTs on frontend clients (GraphQL) JWTs (JSON Web Token, pronounced \u0026lsquo;jot\u0026rsquo;) 正变成一个流行的处理身份认证的方式。本文目标是阐明 JWT 是什么，讨论它的优缺点以及涵盖在客户端实现 JWT",
    "inLanguage" : "zh-cn",
    "author" : "Anson",
    "creator" : "Anson",
    "publisher": "Anson",
    "accountablePerson" : "Anson",
    "copyrightHolder" : "Anson",
    "copyrightYear" : "2022",
    "datePublished": "2022-02-11 22:52:37 \u002b0800 CST",
    "dateModified" : "2022-02-11 22:52:37 \u002b0800 CST",
    "url" : "http:\/\/ansoncode.bazhentu.net\/2022\/008-%E8%AF%91-%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%A4%84%E7%90%86jwts%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97graphql\/",
    "wordCount" : "6178",
    "keywords" : [ "技术翻译","Hasura", "Anson`s Blog"]
}
</script>

  </head>
    <body class="">
        <div class="wrapper">
            <nav class="navbar">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
    <div class="container">
        
            <div class="navbar-header header-back2home-logo">
                <span class="logo_mark" >>$</span>
                <a href="http://ansoncode.bazhentu.net/">
                    <span class="logo_text" >cd /home/</span>
                    <span class="logo_cursor" ></span>
                </a>
            </div>
        
        <div class="navbar-right">
                
                <span class="menu">
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
                <span class="divide"></span>
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a>
                </span>
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
    
        <progress class="content_progress" max="0" value="0"></progress>
    
     <div class="container">
        <div class="navbar">
            <div class="navbar-header header-logo">
                    <a href="http://ansoncode.bazhentu.net/">Anson`s Blog</a>
            </div>
            <div class="navbar-right">
                <div><a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-dark-mode"></i></a></div>
                <div class="menu-toggle">
                    <span></span><span></span><span></span>
                </div>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                <nav class="mb-md">
                    
                    
                        <a class="menu-item" href="/posts/" title="">
                            <h3>Blog</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/categories/" title="">
                            <h3>Categories</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/tags/" title="">
                            <h3>Tags</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                        <a class="menu-item" href="/about/" title="">
                            <h3>About</h3>
                            <div class="menu-active"></div>
                        </a>
                    
                </nav>
        </div>
    </div>
</nav>
            <main class="main">
                <div class="container">
                    
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL）</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="http://ansoncode.bazhentu.net/" rel="author">Anson</a> with ♥
                <span class="post-time">
                on <time datetime=2022-02-11 itemprop="datePublished">February 11, 2022</time>
                </span>
                in
                
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        
                        
                        
                          <a href="http://ansoncode.bazhentu.net/categories/%E7%A0%94%E5%8F%91%E6%8F%90%E6%95%88/"> 研发提效, </a>
                        
                        
                </span>
                <span class="post-word-count">6178 words</span>
        </div>
    </header>

    <div class="post-content">
        

        
        
            
        

        
        
        
        
        

        
        
        

        <p>翻译自：<a href="https://hasura.io/blog/best-practices-of-using-jwt-with-graphql/">The Ultimate Guide to handling JWTs on frontend clients (GraphQL)</a></p>
<p>JWTs (JSON Web Token, pronounced &lsquo;jot&rsquo;) 正变成一个流行的处理身份认证的方式。本文目标是阐明 JWT 是什么，讨论它的优缺点以及涵盖在客户端实现 JWT 的最佳实践，牢记安全。</p>
<p>尽管，我们使用 <a href="https://hasura.io/graphql/">GraphQL</a> 客户端演示，但是这个概念适用于任何前端客户端。</p>
<blockquote>
<p>注意：该指导最早发布于 2019 年 9 月 9 日。 最后更新于 2022 年 1 月 4 日。</p>
</blockquote>
<h1 id="介绍什么是-jwt">介绍：什么是 JWT?</h1>
<h2 id="安全性考虑">安全性考虑</h2>
<h2 id="jwt-结构">JWT 结构</h2>
<h1 id="基础登录">基础：登录</h1>
<p>现在，我们对什么是 JWT 有了基础的理解，让我们创建一个简单的登录流程，并且提取 JWT。下面是我们想要实现的内容：</p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220211234729.png" alt=""></p>
<p><strong>所以，我们如何开始？</strong></p>
<p>这个登录过程和你通常做的实际上没有什么不同。例如，这儿有一个登录表单，提交一个用户名、密码到身份验证端点，并且从响应中获取 JWT 令牌。这可以是使用外部提供者登录、OAuth 和 OAuth2 的步骤。它真的不重要，只要客户端最终在最终登录成功步骤的响应中获取一个 JWT 令牌。</p>
<p>首先，我们将建立一个简单的登录表单给我们的登录服务器发送用户名和密码。服务将签发 JWT 令牌，并且我们将在内存中存储它。在这个练习中，我们不将注意力放在身份授权服务的后端，但是欢迎你在本文的示例仓库中查看它。</p>
<p>下面是登录按钮的<code>handleSubmit</code>处理函数的样子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">handleSubmit</span>() {
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Make the login API call
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">response</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">`/auth/login`</span>, {
    <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;POST&#34;</span>,
    <span style="color:#a6e22e">body</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>({ <span style="color:#a6e22e">username</span>, <span style="color:#a6e22e">password</span> }),
  });
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Extract the JWT from the response
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">jwt_token</span> } <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">json</span>();
  <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Do something the token in the login method
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">login</span>({ <span style="color:#a6e22e">jwt_token</span> });
}
</code></pre></div><p>登录 API 返回一个<strong>令牌</strong>，然后我们把令牌传递给来自<code>/utils/auth</code>的<code>login</code>函数，在那里，我们可以决定一旦我们获取令牌后我们如何处理它。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">login</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;../utils/auth&#34;</span>;
<span style="color:#66d9ef">await</span> <span style="color:#a6e22e">login</span>({ <span style="color:#a6e22e">jwt_token</span> });
</code></pre></div><p><strong>所以，我们已经得到了令牌，现在我们要把令牌存储在那里？</strong></p>
<p>我们需要在某处保存我们的 JWT 令牌，以便于我们能把它作为一个头部传递给我们的 API。你或许尝试在 <code>localstorage</code>中持久化它。不要这样做！这很容易受到 XSS 攻击。</p>
<p><strong>把它存在 cookie 中怎么样？</strong>
在客户端创建 cookies 保存 JWT 也容易受到 XSS。如果它可以在客户端被来自应用外的 JavaScript 读取，它可能被窃取。你或许认为 HttpOnly cookie（被服务端创建而不是客户端）将有帮助，但是 cookies 容易受到 <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html">CSRF</a> 攻击。值得注意的是，HttpOnly 和合理的 CORS 策略不能避免 CSRF 表单提交攻击，并且使用 cookies 需要适当的 CSRF 缓和策略。</p>
<p>注意， <a href="https://owasp.org/www-community/SameSite">SameSite cookie</a>将 使基于 cookie 的方法免受 CSRF 攻击。如果你的 Auth 和 API 服务托管在不同的域名下，它或许不是一个解决方案，否则它将真的工作的很好。</p>
<p><strong>那我们把它存在那里呢？</strong>
<a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.md">The OWASP JWT Cheatsheet</a> 和 <a href="https://github.com/OWASP/ASVS">OWASP ASVS (Application Security Verification Standard)</a> 制定了处理和存储令牌的指导方针。</p>
<p>这部分与在 JWT Cheatsheet 中的 <code>Token Storage on Client Side </code>和 <code>Token Sidejacking</code> 议题，以及 ASVS 的 第三章 (<code>Session Management</code>) 和 第八章 (<code>Data Protection</code>) 相关。</p>
<p>来自备忘单，<code>议题：客户端令牌存储</code>：</p>
<blockquote>
<p>当应用以一种表现下列行为的方式存储令牌令牌时，这种情况就会出现：</p>
</blockquote>
<ul>
<li>
<p>由浏览器自动发送（Cookie 存储）</p>
</li>
<li>
<p>即使浏览器重启也能找到（使用浏览器 localStorage 容器）</p>
</li>
<li>
<p>在出现 XSS 问题时检索（Cookie 可以被 JavaScript 代码访问或令牌存储在浏览器本地或 session 存储中）</p>
<p>如何避免：</p>
</li>
<li>
<p>使用浏览器<code>sessionStorage</code>容器存储令牌</p>
</li>
<li>
<p>当调用服务时，使用 JavaScript 把它添加到 Bearer HTTP <code>Authentication</code> 头中</p>
</li>
<li>
<p>为令牌增加<code>fingerprint指纹</code>信息</p>
</li>
</ul>
<p>将令牌存储在浏览器 sessionStorage 容器中，它暴露了令牌，使它能被 XSS 攻击窃取。然而，为令牌增加指纹避免被盗的令牌在攻击者自己的机器上重复使用。为了关闭一个攻击者最大限度的攻击面，为浏览器增加<code>Content Security Policy（内容安全策略）</code>去强化执行上下文。</p>
<p><code>fingerprint指纹</code>是参考<code>Token Sidejacking </code>议题以下指导方针的实现。</p>
<blockquote>
<p>当令牌被攻击者拦截或盗取时，攻击出现，他们使用令牌获取目标用户身份的系统权限。</p>
</blockquote>
<p>如何避免：</p>
<p>一种方式是在 token 中增加“用户上下文”。用户上下文由以下信息组成：</p>
<ul>
<li>随机字符串在身份验证阶段生成。它将作为一个加强的 cookie 被发送到客户端（标识：HttpOnly + Secure + SameSite + cookie 前缀）。</li>
<li>随机字符串的 SHA256 hash 将存储到令牌中（而不是原始值），以防止任何 XSS 问题，允许攻击者读随机的字符串值并且设置预期的 cookie。</li>
</ul>
<p>IP 地址不应该被使用，因为在一些合理的场合下，IP 地址会在同一个会话中发生变化。例如，当用户通过移动设备访问应用时，手机运营商在交换期间改变，然后 IP 地址或许（经常）变化。而且，使用 IP 地址会造成符合欧洲 GDPR 法规的潜在问题。</p>
<p>在令牌校验期间，如果接收到的令牌不包含正确的上下文（例如，如果它被重放），它一定会被拒绝。</p>
<p>在客户端的一个实现可能如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// Short duration JWT token (5-10 min)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getJwtToken</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#e6db74">&#34;jwt&#34;</span>);
}

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setJwtToken</span>(<span style="color:#a6e22e">token</span>) {
  <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#34;jwt&#34;</span>, <span style="color:#a6e22e">token</span>);
}

<span style="color:#75715e">// Longer duration refresh token (30-60 min)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRefreshToken</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">getItem</span>(<span style="color:#e6db74">&#34;refreshToken&#34;</span>);
}

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setRefreshToken</span>(<span style="color:#a6e22e">token</span>) {
  <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#34;refreshToken&#34;</span>, <span style="color:#a6e22e">token</span>);
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">handleLogin</span>({ <span style="color:#a6e22e">email</span>, <span style="color:#a6e22e">password</span> }) {
  <span style="color:#75715e">// Call login method in API
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// The server handler is responsible for setting user fingerprint cookie during this as well
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">const</span> { <span style="color:#a6e22e">jwtToken</span>, <span style="color:#a6e22e">refreshToken</span> } <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">login</span>({ <span style="color:#a6e22e">email</span>, <span style="color:#a6e22e">password</span> });
  <span style="color:#a6e22e">setJwtToken</span>(<span style="color:#a6e22e">jwtToken</span>);
  <span style="color:#a6e22e">setRefreshToken</span>(<span style="color:#a6e22e">refreshToken</span>);

  <span style="color:#75715e">// If you like, you may redirect the user now
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Router</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;/some-url&#34;</span>);
}
</code></pre></div><p>是的，当用户切换 tabs 时，令牌将为空，但是我们将稍后处理它。</p>
<p><strong>好的！现在我们我们有了令牌，我们能用它做什么？</strong></p>
<ul>
<li>在 API 客户端使用它作为一个 header 传递给每个 API 调用</li>
<li>通过看 JWT 变量是否被设置，核查用户是否登录</li>
<li>可选的，我们甚至能在客户端解码 JWT 访问负载中的数据。</li>
</ul>
<p>假设在客户端我们需要 user_id 或用户名，我们能从 JWT 中获取。</p>
<p><strong>如果我们已经登录，我们如何核查？</strong></p>
<p>如果令牌变量已设置，继续执行，不然的话跳转到登录页。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">jwtToken</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getJwtToken</span>();
<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">jwtToken</span>) {
  <span style="color:#a6e22e">Router</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;/login&#34;</span>);
}
</code></pre></div><h1 id="基础客户端设置">基础：客户端设置</h1>
<p>现在，是时候设置我们的 GraphQL 客户端了。从我们设置的变量中获取令牌，如果它存在，我们把它传递给 GraphQL 客户端。</p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220212193853.png" alt="Using the JWT in a GraphQL client" loading="lazy" ></p>
<p>假定你的 GraphQL API 以<code>Authorization</code>头的形式接收 JWT 授权令牌，你需要去做的就是设置你的客户端从变量中使用 jwt 令牌设置 http 头。</p>
<p>以下是使用 Apollo GraphQL 客户端的 ApolloLink 中间件设置。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useMemo</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;react&#34;</span>
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">ApolloClient</span>, <span style="color:#a6e22e">InMemoryCache</span>, <span style="color:#a6e22e">HttpLink</span>, <span style="color:#a6e22e">ApolloLink</span>, <span style="color:#a6e22e">Operation</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;@apollo/client&#34;</span>
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">getMainDefinition</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;@apollo/client/utilities&#34;</span>
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">WebSocketLink</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;@apollo/client/link/ws&#34;</span>
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">merge</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;deepmerge&#34;</span>

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">apolloClient</span>

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getHeaders</span>() {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">headers</span> <span style="color:#f92672">=</span> {} <span style="color:#a6e22e">as</span> <span style="color:#a6e22e">HeadersInit</span>
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">token</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getJwtToken</span>()
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">token</span>) <span style="color:#a6e22e">headers</span>[<span style="color:#e6db74">&#34;Authorization&#34;</span>] <span style="color:#f92672">=</span> <span style="color:#e6db74">`Bearer </span><span style="color:#e6db74">${</span><span style="color:#a6e22e">token</span><span style="color:#e6db74">}</span><span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">headers</span>
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">operationIsSubscription</span>(<span style="color:#a6e22e">operation</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">Operation</span>)<span style="color:#f92672">:</span> <span style="color:#66d9ef">boolean</span> {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">definition</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getMainDefinition</span>(<span style="color:#a6e22e">operation</span>.<span style="color:#a6e22e">query</span>)
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">isSubscription</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">definition</span>.<span style="color:#a6e22e">kind</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;OperationDefinition&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">definition</span>.<span style="color:#a6e22e">operation</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;subscription&#34;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">isSubscription</span>
}

<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">wsLink</span>
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getOrCreateWebsocketLink</span>() {
    <span style="color:#a6e22e">wsLink</span> <span style="color:#f92672">??=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">WebSocketLink</span>({
        <span style="color:#a6e22e">uri</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>[<span style="color:#e6db74">&#34;NEXT_PUBLIC_HASURA_ENDPOINT&#34;</span>].<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34;http&#34;</span>, <span style="color:#e6db74">&#34;ws&#34;</span>).<span style="color:#a6e22e">replace</span>(<span style="color:#e6db74">&#34;https&#34;</span>, <span style="color:#e6db74">&#34;wss&#34;</span>),
        <span style="color:#a6e22e">options</span><span style="color:#f92672">:</span> {
            <span style="color:#a6e22e">reconnect</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">true</span>,
            <span style="color:#a6e22e">timeout</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">30000</span>,
            <span style="color:#a6e22e">connectionParams</span><span style="color:#f92672">:</span> () =&gt; {
                <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">headers</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">getHeaders</span>() }
            },
        },
    })
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">wsLink</span>
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createLink</span>() {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">httpLink</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">HttpLink</span>({
        <span style="color:#a6e22e">uri</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>[<span style="color:#e6db74">&#34;NEXT_PUBLIC_HASURA_ENDPOINT&#34;</span>],
        <span style="color:#a6e22e">credentials</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;include&#34;</span>,
    })

    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">authLink</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ApolloLink</span>((<span style="color:#a6e22e">operation</span>, <span style="color:#a6e22e">forward</span>) =&gt; {
        <span style="color:#a6e22e">operation</span>.<span style="color:#a6e22e">setContext</span>(({ <span style="color:#a6e22e">headers</span> <span style="color:#f92672">=</span> {} }) =&gt; ({
            <span style="color:#a6e22e">headers</span><span style="color:#f92672">:</span> {
                ...<span style="color:#a6e22e">headers</span>,
                ...<span style="color:#a6e22e">getHeaders</span>(),
            },
        }))
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">forward</span>(<span style="color:#a6e22e">operation</span>)
    })

    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> window <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;undefined&#34;</span>) {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">from</span>([
            <span style="color:#a6e22e">authLink</span>,
            <span style="color:#75715e">// Use &#34;getOrCreateWebsocketLink&#34; to init WS lazily
</span><span style="color:#75715e"></span>            <span style="color:#75715e">// otherwise WS connection will be created + used even if using &#34;query&#34;
</span><span style="color:#75715e"></span>            <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">split</span>(<span style="color:#a6e22e">operationIsSubscription</span>, <span style="color:#a6e22e">getOrCreateWebsocketLink</span>, <span style="color:#a6e22e">httpLink</span>),
        ])
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">from</span>([<span style="color:#a6e22e">authLink</span>, <span style="color:#a6e22e">httpLink</span>])
    }
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">createApolloClient</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">ApolloClient</span>({
        <span style="color:#a6e22e">ssrMode</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">typeof</span> window <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;undefined&#34;</span>,
        <span style="color:#a6e22e">link</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">createLink</span>(),
        <span style="color:#a6e22e">cache</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">InMemoryCache</span>(),
    })
}

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">initializeApollo</span>(<span style="color:#a6e22e">initialState</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">_apolloClient</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">apolloClient</span> <span style="color:#f92672">??</span> <span style="color:#a6e22e">createApolloClient</span>()

    <span style="color:#75715e">// If your page has Next.js data fetching methods that use Apollo Client, the initial state
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// get hydrated here
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">initialState</span>) {
        <span style="color:#75715e">// Get existing cache, loaded during client side data fetching
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">existingCache</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">_apolloClient</span>.<span style="color:#a6e22e">extract</span>()

        <span style="color:#75715e">// Merge the existing cache into data passed from getStaticProps/getServerSideProps
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">merge</span>(<span style="color:#a6e22e">initialState</span>, <span style="color:#a6e22e">existingCache</span>)

        <span style="color:#75715e">// Restore the cache with the merged data
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">_apolloClient</span>.<span style="color:#a6e22e">cache</span>.<span style="color:#a6e22e">restore</span>(<span style="color:#a6e22e">data</span>)
    }

    <span style="color:#75715e">// For SSG and SSR always create a new Apollo Client
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> window <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;undefined&#34;</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_apolloClient</span>
    <span style="color:#75715e">// Create the Apollo Client once in the client
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">apolloClient</span>) <span style="color:#a6e22e">apolloClient</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">_apolloClient</span>

    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_apolloClient</span>
}

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">useApollo</span>(<span style="color:#a6e22e">initialState</span>) {
    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">store</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useMemo</span>(() =&gt; <span style="color:#a6e22e">initializeApollo</span>(<span style="color:#a6e22e">initialState</span>), [<span style="color:#a6e22e">initialState</span>])
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">store</span>
}
</code></pre></div><p>正如你从代码中看到的，无论何时有一个令牌，它作为一个 header 被传递到每个请求中。</p>
<p><strong>但是，如果没有令牌将发生什么？</strong></p>
<p>他依赖于你应用的流程。假设你将用户重定向到登录页：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">else</span> {
 <span style="color:#a6e22e">Router</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;/login&#39;</span>)
}
</code></pre></div><p><strong>如果令牌在我们使用时过期了，将发生什么？</strong></p>
<p>假设我们的令牌仅仅 15 分钟有效。在这种场景下，我们或许将从我们的 API 中获得一个拒绝请求的错误（假设 401 ：未授权错误）。切记，知道如何去使用 JWT 的每个服务能够独立验证它并且核查它是否过期。</p>
<p>让我们为应用增加错误处理去处理该场景。我们将写为每个 API 响应运行且核查错误的代码。当我们从 API 收到令牌过期或非法错误，我们触发注销或跳转到登录工作流。</p>
<p>如果我们正使用 Apollo 客户端，这是代码的样子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">onError</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;apollo-link-error&#34;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">logoutLink</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">onError</span>(({ <span style="color:#a6e22e">networkError</span> }) =&gt; {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">networkError</span>.<span style="color:#a6e22e">statusCode</span> <span style="color:#f92672">===</span> <span style="color:#ae81ff">401</span>) <span style="color:#a6e22e">logout</span>();
});

<span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">typeof</span> window <span style="color:#f92672">!==</span> <span style="color:#e6db74">&#34;undefined&#34;</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">from</span>([
    <span style="color:#a6e22e">logoutLink</span>,
    <span style="color:#a6e22e">authLink</span>,
    <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">split</span>(
      <span style="color:#a6e22e">operationIsSubscription</span>,
      <span style="color:#a6e22e">getOrCreateWebsocketLink</span>,
      <span style="color:#a6e22e">httpLink</span>
    ),
  ]);
} <span style="color:#66d9ef">else</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ApolloLink</span>.<span style="color:#a6e22e">from</span>([<span style="color:#a6e22e">logoutLink</span>, <span style="color:#a6e22e">authLink</span>, <span style="color:#a6e22e">httpLink</span>]);
}
</code></pre></div><p>你或许注意到，这将导致相当糟糕的用户体验。用户将在每次令牌过期时不断被要求重新授权。这是为什么应用实现了一个静默刷新流程，在后台不断刷新 JWT 令牌。在下面的部分会有更多相关内容！</p>
<h1 id="基础注销">基础：注销</h1>
<p>使用 JWTs，“注销”只是在客户端删除令牌，以便它不能被之后的 API 调用使用。</p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220212200912.png" alt=""></p>
<p><strong>所以，是否根本没有<code>注销</code> API 调用？</strong></p>
<p><code>注销</code>端点真的不需要，因为任何接收 JWTs 的微服务将持续接收它。如果你的认证服务删除了 JWT，它也没关系，因为不管怎样其他的服务将保持接收它（因为所有的 JWTs 端点不需要中心协调）。</p>
<p><strong>令牌依然合法，且能被使用。如果我需要确保令牌不能被再次使用，怎么做？</strong></p>
<p>这是为什么 将 JWT 到期值保持小的值是很重要。并且，这是为什么确保你的确保你的 JWTs 不被盗是更重要的了。令牌合法（即使你在客户端删除它），但是只能在短期内降低它被非法使用的可能性。</p>
<p>此外，你可以为 JWTs 增加一个禁用列表。这样，你可以有一个<code>/login</code>API 调用，并且你的认证服务把令牌放入“非法列表”。然而，所有的 API 服务消费 JWT，现在需要为他们的 JWT 验证增加一个额外的步骤去检查中心化的“禁用列表”。这又引入了中心状态，并且带我们回到了使用 JWTs 之前的情况。</p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220212203116.png" alt=""></p>
<p><strong>禁用列表抵消了 JWT 不需要任何中心存储的好处，不是吗？</strong></p>
<p>在某种方式，他确实如此。如果你担心令牌被窃取和滥用，它是你能采取的可选措施，但是它也增加了必须核查的验证的数量。如你所想，这在网络上引起了很多<a href="https://stackoverflow.com/questions/21978658/invalidating-json-web-tokens/52407314#52407314">不满</a>。</p>
<p><strong>如果我在不同的 选项卡 登录将发生什么？</strong></p>
<p>解决该问题的一个方式是在 localstorage 中引入一个全局事件监听。一旦我们在某个选项卡 的 localstorage 中更新注销关键字，在其它 选项卡的监听者将启动,并触发“注销”，同时重定向用户到登录界面。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js">window.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#39;storage&#39;</span>, <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">syncLogout</span>)

<span style="color:#75715e">//....
</span><span style="color:#75715e"></span>
<span style="color:#a6e22e">syncLogout</span> (<span style="color:#a6e22e">event</span>) {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">===</span> <span style="color:#e6db74">&#39;logout&#39;</span>) {
    <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">log</span>(<span style="color:#e6db74">&#39;logged out from storage!&#39;</span>)
    <span style="color:#a6e22e">Router</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#39;/login&#39;</span>)
  }
}
</code></pre></div><p>以下是我们现在需要为注销做的 2 件事：</p>
<ol>
<li>取消令牌</li>
<li>在本地存储中设置<code>注销</code>条目</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useEffect</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;react&#34;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">useRouter</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;next/router&#34;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">gql</span>, <span style="color:#a6e22e">useMutation</span>, <span style="color:#a6e22e">useApolloClient</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;@apollo/client&#34;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">setJwtToken</span>, <span style="color:#a6e22e">setRefreshToken</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;../lib/auth&#34;</span>;

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">SignOutMutation</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">gql</span><span style="color:#e6db74">`
</span><span style="color:#e6db74">  mutation SignOutMutation {
</span><span style="color:#e6db74">    signout {
</span><span style="color:#e6db74">      ok
</span><span style="color:#e6db74">    }
</span><span style="color:#e6db74">  }
</span><span style="color:#e6db74">`</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">SignOut</span>() {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">client</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useApolloClient</span>();
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">router</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">useRouter</span>();
  <span style="color:#66d9ef">const</span> [<span style="color:#a6e22e">signOut</span>] <span style="color:#f92672">=</span> <span style="color:#a6e22e">useMutation</span>(<span style="color:#a6e22e">SignOutMutation</span>);

  <span style="color:#a6e22e">useEffect</span>(() =&gt; {
    <span style="color:#75715e">// Clear the JWT and refresh token so that Apollo doesn&#39;t try to use them
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">setJwtToken</span>(<span style="color:#e6db74">&#34;&#34;</span>);
    <span style="color:#a6e22e">setRefreshToken</span>(<span style="color:#e6db74">&#34;&#34;</span>);
    <span style="color:#75715e">// Tell Apollo to reset the store
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Finally, redirect the user to the home page
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">signOut</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
      <span style="color:#75715e">// to support logging out from all windows
</span><span style="color:#75715e"></span>      window.<span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#34;logout&#34;</span>, Date.<span style="color:#a6e22e">now</span>());
      <span style="color:#a6e22e">client</span>.<span style="color:#a6e22e">resetStore</span>().<span style="color:#a6e22e">then</span>(() =&gt; {
        <span style="color:#a6e22e">router</span>.<span style="color:#a6e22e">push</span>(<span style="color:#e6db74">&#34;/signin&#34;</span>);
      });
    });
  }, [<span style="color:#a6e22e">signOut</span>, <span style="color:#a6e22e">router</span>, <span style="color:#a6e22e">client</span>]);

  <span style="color:#66d9ef">return</span> <span style="color:#f92672">&lt;</span><span style="color:#a6e22e">p</span><span style="color:#f92672">&gt;</span><span style="color:#a6e22e">Signing</span> <span style="color:#a6e22e">out</span>...<span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">/p&gt;;</span>
}
</code></pre></div><p>在这种情况下，当你从一个选项卡注销时，事件监听者将触发所有其他选项卡，并且重定向他们到登录界面。</p>
<p><strong>这可以跨选项卡工作。但是，我如何“强制注销”不同设备上的所有会话？</strong></p>
<p>我们在后面的章节：强制注销，中讨论这个主题的更多细节。</p>
<h1 id="静默刷新">静默刷新</h1>
<p>基于应用的 JWT 用户仍然将面对 2 个主要问题：</p>
<ol>
<li>在 JWTs 上设置更短的过期时间，用户将每 15 分钟注销一次。这是相当糟糕的体验。理想做法，我们或许想让用户长时间登录。</li>
<li>如果用户关闭应用并再次打开它，他们需要再一次登录。他们的会话没有持久化，因为我们没有在客户端的任何地方保存 JWT 令牌。</li>
</ol>
<p>为了解决这个问题，很多 JWT 提供商，提供一个刷新令牌。刷新令牌有 2 个属性：</p>
<ol>
<li>在前一个 JWT 过期前，它被用于发起 API 调用（<code>/refresh_token</code>）去获取一个新的 JWT 令牌。</li>
<li>它可以安全的在客户端跨会话持久化。</li>
</ol>
<p><strong>刷新令牌如何工作？</strong></p>
<p>令牌作为身份验证处理的一部分和 JWT 一起签发。验证服务应该保存刷新令牌并且把它关联到数据库中的一个特定用户上，以便它能处理更新 JWT 逻辑。</p>
<p>在客户端，前一个 JWT 令牌过期前，我们连接我们的应用，去创建<code>/refresh_token</code>端点，并且获取一个新的 JWT。</p>
<p><strong>刷新令牌如何在客户端安全的持久化？</strong></p>
<p>同 JWT 令牌一样。</p>
<p><strong>所以，新的“登录”流程懒起来像什么？</strong></p>
<p>除了刷新令牌随着 JWT 一起发送之外，没有什么变化。我们再看一下登录处理流程图，但是，现在加上了<code>refresh_token</code>功能。</p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220212231755.png" alt=""></p>
<ol>
<li>用户使用登录 API 调用登录</li>
<li>服务产生 JWT 令牌和<code>刷新令牌</code>以及<code>指纹</code></li>
<li>服务返回 JWT 令牌和刷新令牌以及在令牌声明中的指纹 <code>SHA256</code> 哈希版本</li>
<li>生成指纹的非哈希版本被存储在客户端上加固的 <code>HttpOnly</code> cookie 中</li>
<li>当 JWT 令牌过期时，静默刷新将发生。这是客户端调用 <code>/refresh</code> 令牌端点的时机。</li>
</ol>
<p><strong>现在，静默刷新看起来像什么？</strong></p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220212232827.png" alt=""></p>
<p>发生了什么：</p>
<ol>
<li>刷新端点必须核查指纹 cookie 的存在，并且验证令牌声明中的哈希值与 cookie 中的非哈希值对比完全相同。</li>
<li>如果这两个条件没有被满足，刷新请求被拒绝。</li>
<li>否则，刷新令牌被接受，并且授予一个新的 JWT 访问令牌，重置静默刷新过程。</li>
</ol>
<p>使用 <code>apollo-link-token-refresh</code> 包实现该工作流的过程如下所示。</p>
<p>使用它作为非终止链接将自动核查 JWT 的有效性，并且当运行任何操作是，如果需要的话，尝试静默刷新。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">TokenRefreshLink</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;apollo-link-token-refresh&#34;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">JwtPayload</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;jwt-decode&#34;</span>;
<span style="color:#66d9ef">import</span> { <span style="color:#a6e22e">getJwtToken</span>, <span style="color:#a6e22e">getRefreshToken</span>, <span style="color:#a6e22e">setJwtToken</span> } <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;./auth&#34;</span>;
<span style="color:#66d9ef">import</span> <span style="color:#a6e22e">decodeJWT</span> <span style="color:#a6e22e">from</span> <span style="color:#e6db74">&#34;jwt-decode&#34;</span>;

<span style="color:#66d9ef">export</span> <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeTokenRefreshLink</span>() {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">TokenRefreshLink</span>({
    <span style="color:#75715e">// Indicates the current state of access token expiration
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// If token not yet expired or user doesn&#39;t have a token (guest) true should be returned
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">isTokenValidOrUndefined</span><span style="color:#f92672">:</span> () =&gt; {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">token</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getJwtToken</span>();

      <span style="color:#75715e">// If there is no token, the user is not logged in
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// We return true here, because there is no need to refresh the token
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">token</span>) <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;

      <span style="color:#75715e">// Otherwise, we check if the token is expired
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">claims</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">JwtPayload</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">decodeJWT</span>(<span style="color:#a6e22e">token</span>);
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">expirationTimeInSeconds</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">claims</span>.<span style="color:#a6e22e">exp</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1000</span>;
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">now</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Date();
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">isValid</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">expirationTimeInSeconds</span> <span style="color:#f92672">&gt;=</span> <span style="color:#a6e22e">now</span>.<span style="color:#a6e22e">getTime</span>();

      <span style="color:#75715e">// Return true if the token is still valid, otherwise false and trigger a token refresh
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">isValid</span>;
    },
    <span style="color:#75715e">// Responsible for fetching refresh token
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fetchAccessToken</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">async</span> () =&gt; {
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">jwt</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">decodeJWT</span>(<span style="color:#a6e22e">getJwtToken</span>());
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">refreshToken</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getRefreshToken</span>();
      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">fingerprintHash</span> <span style="color:#f92672">=</span>
        <span style="color:#a6e22e">jwt</span><span style="color:#f92672">?</span>.[<span style="color:#e6db74">&#34;https://hasura.io/jwt/claims&#34;</span>]<span style="color:#f92672">?</span>.[<span style="color:#e6db74">&#34;X-User-Fingerprint&#34;</span>];

      <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">request</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#a6e22e">process</span>.<span style="color:#a6e22e">env</span>[<span style="color:#e6db74">&#34;NEXT_PUBLIC_HASURA_ENDPOINT&#34;</span>], {
        <span style="color:#a6e22e">method</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;POST&#34;</span>,
        <span style="color:#a6e22e">headers</span><span style="color:#f92672">:</span> {
          <span style="color:#e6db74">&#34;Content-Type&#34;</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;application/json&#34;</span>,
        },
        <span style="color:#a6e22e">body</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>({
          <span style="color:#a6e22e">query</span><span style="color:#f92672">:</span> <span style="color:#e6db74">`
</span><span style="color:#e6db74">                  query RefreshJwtToken($refreshToken: String!, $fingerprintHash: String!) {
</span><span style="color:#e6db74">                    refreshJwtToken(refreshToken: $refreshToken, fingerprintHash: $fingerprintHash) {
</span><span style="color:#e6db74">                      jwt
</span><span style="color:#e6db74">                    }
</span><span style="color:#e6db74">                  }
</span><span style="color:#e6db74">                `</span>,
          <span style="color:#a6e22e">variables</span><span style="color:#f92672">:</span> {
            <span style="color:#a6e22e">refreshToken</span>,
            <span style="color:#a6e22e">fingerprintHash</span>,
          },
        }),
      });

      <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">request</span>.<span style="color:#a6e22e">json</span>();
    },
    <span style="color:#75715e">// Callback which receives a fresh token from Response.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// From here we can save token to the storage
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">handleFetch</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">accessToken</span>) =&gt; {
      <span style="color:#a6e22e">setJwtToken</span>(<span style="color:#a6e22e">accessToken</span>);
    },
    <span style="color:#a6e22e">handleResponse</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">operation</span>, <span style="color:#a6e22e">accessTokenField</span>) =&gt; (<span style="color:#a6e22e">response</span>) =&gt; {
      <span style="color:#75715e">// here you can parse response, handle errors, prepare returned token to
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// further operations
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// returned object should be like this:
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// {
</span><span style="color:#75715e"></span>      <span style="color:#75715e">//    access_token: &#39;token string here&#39;
</span><span style="color:#75715e"></span>      <span style="color:#75715e">// }
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> { <span style="color:#a6e22e">access_token</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">response</span>.<span style="color:#a6e22e">refreshToken</span>.<span style="color:#a6e22e">jwt</span> };
    },
    <span style="color:#a6e22e">handleError</span><span style="color:#f92672">:</span> (<span style="color:#a6e22e">err</span>) =&gt; {
      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">warn</span>(<span style="color:#e6db74">&#34;Your refresh token is invalid. Try to reauthenticate.&#34;</span>);
      <span style="color:#a6e22e">console</span>.<span style="color:#a6e22e">error</span>(<span style="color:#a6e22e">err</span>);
      <span style="color:#75715e">// Remove invalid tokens
</span><span style="color:#75715e"></span>      <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">removeItem</span>(<span style="color:#e6db74">&#34;jwt&#34;</span>);
      <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">removeItem</span>(<span style="color:#e6db74">&#34;refreshToken&#34;</span>);
    },
  });
}
</code></pre></div><p>回到本节，地址：“如果我在多个选项卡登录，将发生什么?”，使用 <code>sessionStorage</code> 来实现意味着，我们不能在新的选项卡或窗口授权。</p>
<p>在仍然安全的情况下，潜在的解决方案是再一次使用 <code>localStorage</code>作为一个事件触发，并且在加载相同基础 URL 选项卡之间同步 <code>sessionStorage</code>。</p>
<p>这可以通过使用如下的脚本实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">length</span>) {
  <span style="color:#75715e">// Ask other tabs for session storage
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#34;getSessionStorage&#34;</span>, String(Date.<span style="color:#a6e22e">now</span>()));
}

window.<span style="color:#a6e22e">addEventListener</span>(<span style="color:#e6db74">&#34;storage&#34;</span>, (<span style="color:#a6e22e">event</span>) =&gt; {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;getSessionStorage&#34;</span>) {
    <span style="color:#75715e">// Some tab asked for the sessionStorage -&gt; send it
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#e6db74">&#34;sessionStorage&#34;</span>, <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">stringify</span>(<span style="color:#a6e22e">sessionStorage</span>));
    <span style="color:#a6e22e">localStorage</span>.<span style="color:#a6e22e">removeItem</span>(<span style="color:#e6db74">&#34;sessionStorage&#34;</span>);
  } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">key</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;sessionStorage&#34;</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span><span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">length</span>) {
    <span style="color:#75715e">// sessionStorage is empty -&gt; fill it
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">JSON</span>.<span style="color:#a6e22e">parse</span>(<span style="color:#a6e22e">event</span>.<span style="color:#a6e22e">newValue</span>);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">key</span> <span style="color:#66d9ef">in</span> <span style="color:#a6e22e">data</span>) {
      <span style="color:#a6e22e">sessionStorage</span>.<span style="color:#a6e22e">setItem</span>(<span style="color:#a6e22e">key</span>, <span style="color:#a6e22e">data</span>[<span style="color:#a6e22e">key</span>]);
    }
  }
});
</code></pre></div><h1 id="会话持久化">会话持久化</h1>
<p>会话持久化违反了 OWASP 的客户端和令牌身份验证的安全指导规则：</p>
<blockquote>
<p><a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.md#symptom-4">https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.md#symptom-4</a></p>
</blockquote>
<p>创作本文时，没有一种方法可以在浏览器关闭并重新打开后允许用户会话持久化，除非浏览器实现保留选项卡 session 状态（<code>sessionStorage</code>）。</p>
<p>为了跨浏览器重启持久化会话，你或许选择在 <code>localStorage</code> 中或者 <code>Cookie</code> 存储你的令牌，但是一定要慎重。</p>
<blockquote>
<p>有关该主题的讨论，见：https://github.com/OWASP/ASVS/issues/1141</p>
</blockquote>
<h1 id="强制登出又名注销所有会话设备">强制登出，又名注销所有会话/设备</h1>
<p>现在，用户永久登录了并且在会话之间保持登录态，出现一个新的问题，我们需要关心：强制登出或者注销所有的会话和设备</p>
<p>上述章节刷新令牌的实现表明，我们能持久化会话，并且保持登录。</p>
<p>在这种情形下，一个简单地“强制登出”实现是要求认证服务使特定用户相关的所有刷新令牌失效。</p>
<p>这是在认证服务后端的主要实现，并且不需要在客户端任何特别的处理。除了你应用上的“强制注销”按钮。</p>
<h1 id="服务端渲染ssr">服务端渲染（SSR）</h1>
<p>在处理 JWT 令牌时，在服务端渲染涉及额外的复杂性。</p>
<p>这是我们想要的：</p>
<ol>
<li>浏览器向应用 URL 发起请求</li>
<li>SSR 服务基于用户身份渲染页面</li>
<li>用户获得渲染页，然后继续使用应用作为单页应用（SPA）</li>
</ol>
<h2 id="如果用户登录ssr-服务如何知道">如果用户登录，SSR 服务如何知道？</h2>
<p>浏览器需要向 SSR 服务发送一些关于当前用户身份信息。做这的唯一方式是通过 cookie。</p>
<p>因为我们早已通过 cookies 实现了刷新令牌工作流，当我们向 SSR 服务发起请求时，我们需要确保刷新令牌也一起发送。</p>
<blockquote>
<p><strong>注意</strong>：对于经过认证的 SSR 页面，认证 API 的域（以及 refresh_token cookie 的域）与 SSR 服务的域相同是至关重要的。否则，我们的 cookies 不能发送到 SSR 服务！</p>
</blockquote>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220213002655.png" alt=""></p>
<p>这是 SSR 服务做的：</p>
<ol>
<li>在收到渲染特定页面的请求时，SSR 服务捕获 refresh_token cookie</li>
<li>SSR 服务使用 refresh_token cookie 为用户获取一个新的 JWT</li>
<li>SSR 服务使用新的 JWT 令牌，发起所有授权的 GraphQL 请求去获取正确的数据</li>
</ol>
<p><strong>一旦 SSR 页面加载完毕后，用户能继续发起授权请求吗？</strong></p>
<p>不，不幸的是，如果没有额外的折腾，就不会这样!（意思是还是要额外处理）</p>
<p>一旦 SSR 服务返回渲染的 HTML，浏览器上仅存的关于用户身份的标识是旧的刷新令牌 cookie，它已经被 SSR 服务使用过了。</p>
<p>如果我们应用代码尝试使用这个刷新令牌 cookie 去获取新的 JWT，这个请求将失败并且用户将退出登录。</p>
<p>为了解决这个，SSR 服务渲染页面之后需要发送最新的 <code>refresh token cookie</code>，以便于浏览器使用它。</p>
<p><strong>整个 SSR 流程，首尾相连</strong></p>
<p><img src="https://gitee.com/caoyanbin/picgo/raw/master/img/20220213003641.png" alt=""></p>
<h1 id="本文的代码已完成的应用">本文的代码（已完成的应用）</h1>
<p>本文示例代码包含端到端工作应用，以及 SSR 能力。</p>
<p><a href="https://github.com/hasura/jwt-guide">https://github.com/hasura/jwt-guide</a></p>
<p>该仓库也包含身份验证后端代码示例。</p>
<h1 id="尝试它">尝试它</h1>
<p>使用 Hasura Cloud 设置免费的 GraphQL 后端，尝试它！</p>
<p>确保你的版本在 1.3 及之上，你可以出发了！</p>
<h1 id="参考">参考</h1>
<ul>
<li>
<p>JWT.io</p>
</li>
<li>
<p>OWASP notes on XSS, CSRF and similar things</p>
<ul>
<li><a href="https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html">OWASP JWT Cheatsheet</a></li>
<li><a href="https://github.com/OWASP/ASVS">OWASP Application Security Verification Standard, v5</a></li>
</ul>
</li>
<li>
<p>The Parts of JWT Security Nobody Talks About | Philippe De Ryck</p>
</li>
<li>
<p><a href="https://hasura.io/blog/optimistic-ui-and-clobbering/">Optimistic UI and Clobbering</a></p>
</li>
</ul>
<h1 id="总结">总结</h1>
<p>一旦你按照所有上述章节操作，你的应用将具有现代应用的能力，使用 JWT 并且能避免 JWT 实现过程中的主要安全缺陷。</p>
<p>如果你有任何问题，建议或者反馈，请在 <a href="https://twitter.com/HasuraHQ">Twitter</a> 或者在下面评论区告诉我们！</p>

    </div>

    <div class="post-copyright">
            
            <p class="copyright-item">
                <span>Author:</span>
                <span>Anson </span>
                </p>
            


            
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=http://ansoncode.bazhentu.net/2022/008-%E8%AF%91-%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%A4%84%E7%90%86jwts%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97graphql/>http://ansoncode.bazhentu.net/2022/008-%E8%AF%91-%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%A4%84%E7%90%86jwts%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97graphql/</span>
            </p>
            
            
            <div id="qr_code_pc_outer" >
                <img src=https://api.qrserver.com/v1/create-qr-code/?size&#61;150x150&amp;data&#61;http://ansoncode.bazhentu.net/2022/008-%E8%AF%91-%E5%9C%A8%E5%89%8D%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8A%E5%A4%84%E7%90%86jwts%E7%9A%84%E7%BB%88%E6%9E%81%E6%8C%87%E5%8D%97graphql/>
                <p>扫一扫<br>阅读文章</p>
            </div>
            <script>
                if( /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ) {
                    
                    
                    
                }else{
                    document.getElementById('qr_code_pc_outer').style.display="block"
                }
            </script>
            <style> 
            p { word-wrap:break-word; }
                #qr_code_pc_outer {
                    display: none;
                    color: #717375;
                     
                    position: fixed;
                    right: 100px;
                    text-align: center;
                    top: 200px;
                    }
                #qr_code_pc_outer img{
                    width: 100px;height: 100px;
                }
                #qr_code_pc_outer p{
                    font-size: 0.5em;
                }
            </style>
            
            
            <p class="copyright-item">
                <span>Expect:</span>
                <span>专注云开发相关技术及产品，寻找合作机会 </span>
                </p>
            
            
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>


    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s):
            
            <span class="tag"><a href="http://ansoncode.bazhentu.net/tags/%E6%8A%80%E6%9C%AF%E7%BF%BB%E8%AF%91/">
                    #技术翻译</a></span>
            
            <span class="tag"><a href="http://ansoncode.bazhentu.net/tags/hasura/">
                    #Hasura</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> ·
                <span><a href="http://ansoncode.bazhentu.net/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://ansoncode.bazhentu.net/2022/006-%E8%AF%91-serverless%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6openfaasknative%E7%AD%89/" class="prev" rel="prev" title="006 译 | Serverless开源框架：OpenFaaS,Knative等"><i class="iconfont icon-left"></i>&nbsp;006 译 | Serverless开源框架：OpenFaaS,Knative等</a>
        
        
        <a href="http://ansoncode.bazhentu.net/2022/009-%E8%AF%91-%E4%B9%90%E8%A7%82ui%E5%92%8C%E6%A1%A3%E6%A1%88%E9%94%80%E6%AF%81/" class="next" rel="next" title="009 译 | 乐观UI和档案销毁">009 译 | 乐观UI和档案销毁&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
        
            
                <div id="tcomment"></div>
<script src="https://cdn.jsdelivr.net/npm/twikoo@1.0.0/dist/twikoo.all.min.js"></script>
<script>twikoo.init({ envId: 'anson-blog-talk-8gwaudnw7b5c558b', el: '#tcomment' })</script>
            
        
    </div>
</article>
                </div>
            </main>
            <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2017 - 2022</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i>
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://ansoncode.bazhentu.net/">Anson</a> | </span>
         

         
            <a href="http://www.miibeian.gov.cn/" target="_blank" rel="external nofollow">陕ICP备17023607号-1 </a> |
         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/Mogeko/Mogege" target="_blank" rel="external nofollow">Mogege</a></span>
    </div>
</footer>








<script defer src="/js/vendor_main.min.js"></script>







<script src="https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script> pangu.spacingPage();</script>






  <script>
    
    function loadJs(url) {
        return new Promise((resolve, reject) => {
            var script = document.createElement('script');
            script.type = "text/javascript";
            if (script.readyState) {
                script.onreadystatechange = function () {
                    if (script.readyState == "loaded" || script.readyState == "complete") {
                        script.onreadystatechange = null;
                        
                        resolve()
                    }
                }
            } else {
                script.onload = function () {
                    
                    resolve()
                }
            }
            script.src = url;
            document.body.appendChild(script);
        })

    }
    function loadManyJs(arr) {
        return new Promise(async (resolve, reject) => {
            for (let i = 0; i < arr.length; i++) {
                let jsUrl = arr[i]
                try {
                    await loadJs(jsUrl)
                } catch (error) {
                    reject(error)
                }
            }
            resolve()
        })
    }

    
    var currurl = location.href.split('#')[0]
    let userAgent = navigator.userAgent.toLowerCase();
    let isWeixin = userAgent.match(/MicroMessenger/i) == "micromessenger"
    let isMobile=/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
    let arr = [
        "//astyle-src.alicdn.com/app/searchweb/products/zhaohuoshenqi/lib/jquery.js",
        "//res.wx.qq.com/open/js/jweixin-1.6.0.js"
    ]
    if (isMobile) {
        
        loadManyJs(arr).then(async () => {
            console.log('仅微信端需要执行下面的操作', currurl)
            let title = '008 译 | 在前端客户端上处理JWTs的终极指南（GraphQL）'
            console.log('title', title)
            let desc = 'anson会写代码的产品经理，这是我的技术博客，专注产品设计及软件开发。'
            let imgUrl =  "https://ansoncode.bazhentu.net/myblogtalk/img/PfjiWupdZrtzINV.png" 
            

            let link =  "https://wechat-mp-8geeep1wd1373392-1253693669.ap-shanghai.app.tcloudbase.com/koa-starter/getSign"
            let data = await JQ.get(link, { url: currurl })
            console.log(data)
            
            
            
            
            
            
            let debug= false 
            wx.config({
                debug: debug, 
                appId: data.appId, 
                timestamp: data.timestamp, 
                nonceStr: data.nonceStr, 
                signature: data.signature,
                jsApiList: ["checkJsApi", "updateAppMessageShareData", "onMenuShareTimeline", "onMenuShareAppMessage", "onMenuShareQQ", "onMenuShareQZone"] 
            });
  
            wx.ready(function () {
                
                wx.checkJsApi({
                    jsApiList: ["checkJsApi", "updateAppMessageShareData", "onMenuShareTimeline", "onMenuShareAppMessage", "onMenuShareQQ", "onMenuShareQZone"], 
                    success: function (res) {
                        
                        
                        
                        
                    }
                });
                
                wx.updateAppMessageShareData({
                    title: title, 
                    desc: desc, 
                    link: currurl, 
                    imgUrl: imgUrl, 
                    success: function () {
                        
                    }
                })
                
                
                
                
                
                
                
                
                
                
                
                wx.onMenuShareTimeline({
                    title: title, 
                    desc: desc, 
                    link: currurl, 
                    imgUrl: imgUrl, 
                    success: function (res) {
                    },
                    cancel: function (res) {
                    },
                    fail: function (res) {
                        alert(JSON.stringify(res));
                    }
                });
                
                wx.onMenuShareAppMessage({
                    title: title, 
                    desc: desc, 
                    link: currurl, 
                    imgUrl: imgUrl, 
                    type: '', 
                    dataUrl: '', 
                    success: function () {
                        
                    },
                    cancel: function () {
                        
                    }
                });
                
                wx.onMenuShareQQ({
                    title: title, 
                    desc: desc, 
                    link: currurl, 
                    imgUrl: imgUrl, 
                    success: function () {
                        
                    },
                    cancel: function () {
                        
                    }
                });
                
                wx.onMenuShareQZone({
                    title: title, 
                    desc: desc, 
                    link: currurl, 
                    imgUrl: imgUrl, 
                    success: function () {
                        
                    },
                    cancel: function () {
                        
                    }
                });

            });
            wx.error(function (res) {
                
                console.log("初始化wx.config失败" + res)
            });
        }).catch(err => {
            console.log('load js error', err)
        })
    }


</script>


        </div>
    </body>
</html>
